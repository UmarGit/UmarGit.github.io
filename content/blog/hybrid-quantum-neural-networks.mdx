---
title: "Hybrid Quantum Neural Networks: Visualizing Geometric Advantage"
description: "Classical Neural Networks struggle with complex topologies like rings and donuts. In this post, we visualize how Hybrid Quantum Neural Networks use entanglement to solve these geometries instantly."
date: "2025-12-30"
tags: ["quantum computing", "pytorch", "qiskit", "machine learning", "research"]
author:
  name: "Umar Ahmed"
  title: "Senior Software Engineer & ML Researcher"
---

We often hear about **Quantum Advantage** in terms of speed. But there is another, perhaps more immediate advantage: **Geometry**.

In this post, we‚Äôll **visualize the decision boundaries** of a Hybrid Quantum Neural Network (HQNN) and prove experimentally how it solves topological problems that baffle standard classical networks.

---

## üìå What is a Hybrid QNN?

A Hybrid QNN combines the best of both worlds:
1.  **Quantum Kernel (The Eye):** Maps data into a high-dimensional Hilbert space to untangle complex patterns.
2.  **Classical Layer (The Brain):** A standard PyTorch neural network that interprets the quantum measurement.

</br>

The secret sauce is **Entanglement**. While a classical neuron draws a straight line (hyperplane), a quantum circuit with entanglement can draw complex, closed-loop shapes naturally.

---

## üìä Step 1: The "Impossible" Dataset

We will use the **Concentric Circles** dataset. This is "topologically complex" because you cannot separate a ring inside a ring with a single straight line.

```python
from sklearn.datasets import make_circles
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
import torch

# 1. Generate Topological Data (Rings)
X, y = make_circles(n_samples=200, noise=0.1, factor=0.2, random_state=42)

# 2. Scale to 0...pi (Crucial for Quantum Rotations)
scaler = MinMaxScaler(feature_range=(0, 3.14))
X_scaled = scaler.fit_transform(X)

# Visualize
plt.figure(figsize=(8, 6))
plt.scatter(X_scaled[:, 0], X_scaled[:, 1], c=y, cmap='viridis', edgecolors='k')
plt.title("The Challenge: Separate the Inner Ring")
plt.show()

```

---

## üß† Step 2: The Quantum Circuit (The Kernel)

To solve this, we need a circuit that "entangles" the X and Y coordinates. We use Qiskit's `ZZFeatureMap`.

* **Classical View:**  and  are separate numbers.
* **Quantum View:** We map them to a state where they interact: . This interaction creates the "curved" geometry.

```python
from qiskit.circuit.library import ZZFeatureMap, EfficientSU2
from qiskit_machine_learning.connectors import TorchConnector
from qiskit_machine_learning.neural_networks import EstimatorQNN
from qiskit.primitives import Estimator

# 1. Feature Map (Encodes Data & Creates Entanglement)
feature_map = ZZFeatureMap(feature_dimension=2, reps=2, entanglement='linear')

# 2. Ansatz (Trainable Weights - The "Quantum Neurons")
ansatz = EfficientSU2(num_qubits=2, reps=2, entanglement='full')

# 3. Combine into a Quantum Circuit
qc = feature_map.compose(ansatz)

```

---

## üîó Step 3: Integrating with PyTorch

This is where the magic happens. We wrap the quantum circuit in a `TorchConnector`, making it behave exactly like a standard PyTorch layer (`nn.Module`). We can now use standard Backpropagation!

```python
import torch.nn as nn

# Define the QNN
qnn = EstimatorQNN(
    circuit=qc,
    input_params=feature_map.parameters,
    weight_params=ansatz.parameters
)

# Create the Hybrid Model
class HybridQNN(nn.Module):
    def __init__(self, qnn):
        super().__init__()

        # The Quantum Layer
        self.qnn = TorchConnector(qnn)

        # The Classical Head (Interpretation)
        self.network = nn.Sequential(
            nn.Linear(input_dim, 8), nn.ReLU(), nn.Linear(8, output_dim)
        )

    def forward(self, x):
        x = self.qnn(x)
        x = self.network(x)
        return x

model = HybridQNN(qnn)

```

---

## üìâ Step 4: Training (Quantum vs Classical)

We trained both this Hybrid model and a standard Classical MLP on the circles.

* **Classical Model:** Standard ReLU Network.
* **Quantum Model:** The Hybrid code above.

```python
# Standard PyTorch Training Loop
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.1)

for epoch in range(epochs):
    optimizer.zero_grad()
    output = model(X_train_tensor)
    loss = criterion(output, y_train_tensor)
    loss.backward()
    optimizer.step()

```

---

## üß© Step 5: The "Smoking Gun" Result

This is the most important part of the research. Let's look at the Decision Boundaries (how the models "see" the world).

### ‚ùå The Classical Failure

The Classical model tries to draw straight lines (ReLU cuts). It hits a geometric wall. It essentially slices the circle in half, failing to isolate the inner ring.

### ‚úÖ The Quantum Success

The Quantum model utilizes the **interference patterns** generated by the `ZZFeatureMap`. It naturally forms a **closed loop** (an island) around the inner class.

* **Accuracy:** Quantum reached **~68%** (and rising) in just 50 epochs, while Classical stalled at **61%**.
* **Geometry:** The 3D landscape shows the Quantum model creating a perfect "volcano" shape to isolate the data.

---

## üìà Step 6: 3D Visualization of the Kernel

We can take it a step further and visualize the "Energy Landscape" in 3D. 

**Classical vs Quantum:** Notice how the Quantum model (right) creates a distinct "hill" for the inner ring, while the Classical model (left) struggles to create depth?

| Classical Convergence | Quantum Convergence |
| :---: | :---: |
| ![Classical Circles](/images/hybrid-quantum-neural-networks/circles/classical_decision_boundary.png) | ![Quantum 3D](/images/hybrid-quantum-neural-networks/circles/quantum_simulator_decision_boundary.png) |
| ![Classical Moons](/images/hybrid-quantum-neural-networks/moon/classical_decision_boundary.png) | ![Quantum Moons](/images/hybrid-quantum-neural-networks/moon/quantum_simulator_decision_boundary.png) |

---

## ‚úÖ Conclusion

This experiment proves a fundamental **Geometric Acceleration**.

While current quantum hardware is slow (in seconds), the quantum **mathematics** is incredibly efficient. It solves complex topological problems (like rings) with a very shallow circuit (Depth 2), whereas a classical network would need deep layers to approximate the same shape.

**Key Takeaway:** For linear data, use Classical. For complex, topological data (like rings, spirals, or protein folding), Hybrid Quantum models act as a powerful "Instant Kernel."

---

*Code for this experiment is available on my [GitHub Repository](https://github.com/UmarGit/hybrid-quantum-neural-network).*
